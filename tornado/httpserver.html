
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>httpserver.py Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="web.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="../SocketServer/">
            
                <a href="../SocketServer/">
            
                    
                    SocketServer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="../asyncore/">
            
                <a href="../asyncore/">
            
                    
                    asyncore
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="../itertools/">
            
                <a href="../itertools/">
            
                    
                    itertools
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="../fn.py/">
            
                <a href="../fn.py/">
            
                    
                    fn.py
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.4.1" data-path="../fn.py/op.html">
            
                <a href="../fn.py/op.html">
            
                    
                    op
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4.2" data-path="../fn.py/func.html">
            
                <a href="../fn.py/func.html">
            
                    
                    func
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4.3" data-path="../fn.py/stream.html">
            
                <a href="../fn.py/stream.html">
            
                    
                    stream
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="../tablib/">
            
                <a href="../tablib/">
            
                    
                    tablib
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="./">
            
                <a href="./">
            
                    
                    tornado
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.6.1" data-path="web.html">
            
                <a href="web.html">
            
                    
                    web.py
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.6.2" data-path="httpserver.html">
            
                <a href="httpserver.html">
            
                    
                    httpserver.py
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >httpserver.py</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <ul>
<li><a href="#%E7%AE%80%E4%BB%8B">&#x7B80;&#x4ECB;</a></li>
<li><a href="#httpserver">HTTPServer</a></li>
<li><a href="#httpconnection">HTTPConnection</a></li>
<li><a href="#httprequest">HTTPRequest</a></li>
</ul>
<h2 id="&#x7B80;&#x4ECB;">&#x7B80;&#x4ECB;</h2>
<p>HTTPServer &#x53EF;&#x4EE5;&#x4F5C;&#x4E3A;&#x4E00;&#x4E2A;&#x72EC;&#x7ACB;&#x7684; http &#x670D;&#x52A1;&#x5668;&#x4F7F;&#x7528;,&#x7ED9;&#x5B83;&#x63D0;&#x4F9B;&#x4E00;&#x4E2A;&#x53EF;&#x8C03;&#x7528;&#x5BF9;&#x8C61;&#xFF0C;&#x6536;&#x5230; request &#x65F6;&#x5373;&#x8C03;&#x7528;&#x8BE5;&#x5BF9;&#x8C61;&#x3002;<br>&#x5BF9;&#x8C61;&#x4E2D;&#x901A;&#x8FC7; write() &#x5199;&#x5165;&#x8FD4;&#x56DE;&#x6570;&#x636E;&#xFF0C;&#x901A;&#x8FC7; finish()&#x7ED3;&#x675F;&#x8FD4;&#x56DE;&#xFF1A;</p>
<pre><code class="lang-python"><span class="hljs-comment">#!/usr/bin/env python</span>
<span class="hljs-comment"># -*- coding: utf-8 -*-</span>

<span class="hljs-keyword">from</span> tornado <span class="hljs-keyword">import</span> httpserver
<span class="hljs-keyword">from</span> tornado <span class="hljs-keyword">import</span> ioloop

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_request</span><span class="hljs-params">(request)</span>:</span>
    message = <span class="hljs-string">&quot;You requested %s\n&quot;</span> % request.uri
    request.write(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\nContent-Length: %d\r\n\r\n%s&quot;</span> % (
        len(message), message))
    request.finish()

http_server = httpserver.HTTPServer(handle_request)
http_server.listen(<span class="hljs-number">8888</span>)
ioloop.IOLoop.instance().start()
</code></pre>
<pre><code class="lang-bash">$ http --verbose <span class="hljs-string">&apos;http://127.0.0.1:8888/hello&apos;</span>
GET /hello HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: 127.0.0.1:8888
User-Agent: HTTPie/0.9.2



HTTP/1.1 200 OK
Content-Length: 21

You requested /hello
</code></pre>
<h2 id="httpserver">HTTPServer</h2>
<p>&#x975E;&#x963B;&#x585E;&#x5355;&#x7EBF;&#x7A0B; http &#x670D;&#x52A1;</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HTTPServer</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-string">&quot;&quot;&quot;A non-blocking, single-threaded HTTP server.

    A server is defined by a request callback that takes an HTTPRequest
    instance as an argument and writes a valid HTTP response with
    request.write(). request.finish() finishes the request (but does not
    necessarily close the connection in the case of HTTP/1.1 keep-alive
    requests). A simple example server that echoes back the URI you
    requested:

        import httpserver
        import ioloop

        def handle_request(request):
           message = &quot;You requested %s\n&quot; % request.uri
           request.write(&quot;HTTP/1.1 200 OK\r\nContent-Length: %d\r\n\r\n%s&quot; % (
                         len(message), message))
           request.finish()

        http_server = httpserver.HTTPServer(handle_request)
        http_server.listen(8888)
        ioloop.IOLoop.instance().start()

    HTTPServer is a very basic connection handler. Beyond parsing the
    HTTP request body and headers, the only HTTP semantics implemented
    in HTTPServer is HTTP/1.1 keep-alive connections. We do not, however,
    implement chunked encoding, so the request callback must provide a
    Content-Length header or implement chunked encoding for HTTP/1.1
    requests for the server to run correctly for HTTP/1.1 clients. If
    the request handler is unable to do this, you can provide the
    no_keep_alive argument to the HTTPServer constructor, which will
    ensure the connection is closed on every request no matter what HTTP
    version the client is using.

    If xheaders is True, we support the X-Real-Ip and X-Scheme headers,
    which override the remote IP and HTTP scheme for all requests. These
    headers are useful when running Tornado behind a reverse proxy or
    load balancer.

    HTTPServer can serve HTTPS (SSL) traffic with Python 2.6+ and OpenSSL.
    To make this server serve SSL traffic, send the ssl_options dictionary
    argument with the arguments required for the ssl.wrap_socket() method,
    including &quot;certfile&quot; and &quot;keyfile&quot;:

       HTTPServer(applicaton, ssl_options={
           &quot;certfile&quot;: os.path.join(data_dir, &quot;mydomain.crt&quot;),
           &quot;keyfile&quot;: os.path.join(data_dir, &quot;mydomain.key&quot;),
       })

    By default, listen() runs in a single thread in a single process. You
    can utilize all available CPUs on this machine by calling bind() and
    start() instead of listen():

        http_server = httpserver.HTTPServer(handle_request)
        http_server.bind(8888)
        http_server.start(0) # Forks multiple sub-processes
        ioloop.IOLoop.instance().start()

    start(0) detects the number of CPUs on this machine and &quot;pre-forks&quot; that
    number of child processes so that we have one Tornado process per CPU,
    all with their own IOLoop. You can also pass in the specific number of
    child processes you want to run with if you want to override this
    auto-detection.
    &quot;&quot;&quot;</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, request_callback, no_keep_alive=False, io_loop=None,
                 xheaders=False, ssl_options=None)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Initializes the server with the given request callback.

        If you use pre-forking/start() instead of the listen() method to
        start your server, you should not pass an IOLoop instance to this
        constructor. Each pre-forked child process will create its own
        IOLoop instance after the forking process.
        &quot;&quot;&quot;</span>
        self.request_callback = request_callback
        self.no_keep_alive = no_keep_alive
        self.io_loop = io_loop
        self.xheaders = xheaders
        self.ssl_options = ssl_options
        self._socket = <span class="hljs-keyword">None</span>
        self._started = <span class="hljs-keyword">False</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">listen</span><span class="hljs-params">(self, port, address=<span class="hljs-string">&quot;&quot;</span>)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Binds to the given port and starts the server in a single process.

        This method is a shortcut for:

            server.bind(port, address)
            server.start(1)

        &quot;&quot;&quot;</span>
        self.bind(port, address)
        self.start(<span class="hljs-number">1</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bind</span><span class="hljs-params">(self, port, address=<span class="hljs-string">&quot;&quot;</span>)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Binds this server to the given port on the given IP address.

        To start the server, call start(). If you want to run this server
        in a single process, you can call listen() as a shortcut to the
        sequence of bind() and start() calls.
        &quot;&quot;&quot;</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> self._socket
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM, <span class="hljs-number">0</span>)
        flags = fcntl.fcntl(self._socket.fileno(), fcntl.F_GETFD)
        flags |= fcntl.FD_CLOEXEC
        fcntl.fcntl(self._socket.fileno(), fcntl.F_SETFD, flags)
        self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)
        self._socket.setblocking(<span class="hljs-number">0</span>)
        self._socket.bind((address, port))
        self._socket.listen(<span class="hljs-number">128</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span><span class="hljs-params">(self, num_processes=<span class="hljs-number">1</span>)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Starts this server in the IOLoop.

        By default, we run the server in this process and do not fork any
        additional child process.

        If num_processes is None or &lt;= 0, we detect the number of cores
        available on this machine and fork that number of child
        processes. If num_processes is given and &gt; 1, we fork that
        specific number of sub-processes.

        Since we use processes and not threads, there is no shared memory
        between any server code.

        Note that multiple processes are not compatible with the autoreload
        module (or the debug=True option to tornado.web.Application).
        When using multiple processes, no IOLoops can be created or
        referenced until after the call to HTTPServer.start(n).
        &quot;&quot;&quot;</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> self._started
        self._started = <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">if</span> num_processes <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span> <span class="hljs-keyword">or</span> num_processes &lt;= <span class="hljs-number">0</span>:
            num_processes = _cpu_count()
        <span class="hljs-keyword">if</span> num_processes &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> ioloop.IOLoop.initialized():
            logging.error(<span class="hljs-string">&quot;Cannot run in multiple processes: IOLoop instance &quot;</span>
                          <span class="hljs-string">&quot;has already been initialized. You cannot call &quot;</span>
                          <span class="hljs-string">&quot;IOLoop.instance() before calling start()&quot;</span>)
            num_processes = <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> num_processes &gt; <span class="hljs-number">1</span>:
            logging.info(<span class="hljs-string">&quot;Pre-forking %d server processes&quot;</span>, num_processes)
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_processes):
                <span class="hljs-keyword">if</span> os.fork() == <span class="hljs-number">0</span>:
                    <span class="hljs-keyword">import</span> random
                    <span class="hljs-keyword">from</span> binascii <span class="hljs-keyword">import</span> hexlify
                    <span class="hljs-keyword">try</span>:
                        <span class="hljs-comment"># If available, use the same method as</span>
                        <span class="hljs-comment"># random.py</span>
                        seed = long(hexlify(os.urandom(<span class="hljs-number">16</span>)), <span class="hljs-number">16</span>)
                    <span class="hljs-keyword">except</span> NotImplementedError:
                        <span class="hljs-comment"># Include the pid to avoid initializing two</span>
                        <span class="hljs-comment"># processes to the same value</span>
                        seed(int(time.time() * <span class="hljs-number">1000</span>) ^ os.getpid())
                    random.seed(seed)
                    self.io_loop = ioloop.IOLoop.instance()
                    self.io_loop.add_handler(
                        self._socket.fileno(), self._handle_events,
                        ioloop.IOLoop.READ)
                    <span class="hljs-keyword">return</span>
            os.waitpid(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># &#x521B;&#x5EFA;&#x4E00;&#x4E2A; io_loop &#x5355;&#x4F8B;</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.io_loop:
                self.io_loop = ioloop.IOLoop.instance()
            <span class="hljs-comment"># &#x589E;&#x52A0;&#x4E8B;&#x4EF6;&#x5904;&#x7406; handler</span>
            self.io_loop.add_handler(self._socket.fileno(),
                                     self._handle_events,
                                     ioloop.IOLoop.READ)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop</span><span class="hljs-params">(self)</span>:</span>
        self.io_loop.remove_handler(self._socket.fileno())
        self._socket.close()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_handle_events</span><span class="hljs-params">(self, fd, events)</span>:</span>
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
            <span class="hljs-keyword">try</span>:
                <span class="hljs-comment"># &#x5EFA;&#x7ACB;&#x8BF7;&#x6C42;</span>
                connection, address = self._socket.accept()
            <span class="hljs-keyword">except</span> socket.error, e:
                <span class="hljs-keyword">if</span> e.args[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):
                    <span class="hljs-keyword">return</span>
                <span class="hljs-keyword">raise</span>
            <span class="hljs-keyword">if</span> self.ssl_options <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">assert</span> ssl, <span class="hljs-string">&quot;Python 2.6+ and OpenSSL required for SSL&quot;</span>
                <span class="hljs-keyword">try</span>:
                    connection = ssl.wrap_socket(connection,
                                                 server_side=<span class="hljs-keyword">True</span>,
                                                 do_handshake_on_connect=<span class="hljs-keyword">False</span>,
                                                 **self.ssl_options)
                <span class="hljs-keyword">except</span> ssl.SSLError, err:
                    <span class="hljs-keyword">if</span> err.args[<span class="hljs-number">0</span>] == ssl.SSL_ERROR_EOF:
                        <span class="hljs-keyword">return</span> connection.close()
                    <span class="hljs-keyword">else</span>:
                        <span class="hljs-keyword">raise</span>
                <span class="hljs-keyword">except</span> socket.error, err:
                    <span class="hljs-keyword">if</span> err.args[<span class="hljs-number">0</span>] == errno.ECONNABORTED:
                        <span class="hljs-keyword">return</span> connection.close()
                    <span class="hljs-keyword">else</span>:
                        <span class="hljs-keyword">raise</span>
            <span class="hljs-keyword">try</span>:
                <span class="hljs-keyword">if</span> self.ssl_options <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
                    stream = iostream.SSLIOStream(connection, io_loop=self.io_loop)
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-comment"># &#x521B;&#x5EFA; stream &#x5BF9;&#x8C61;</span>
                    stream = iostream.IOStream(connection, io_loop=self.io_loop)
                <span class="hljs-comment"># &#x521B;&#x5EFA; HTTPConnection &#x5BF9;&#x8C61;</span>
                <span class="hljs-comment"># stream: stream&#x5BF9;&#x8C61;</span>
                <span class="hljs-comment"># request_callback: &#x7ED1;&#x5B9A;&#x7684;&#x56DE;&#x8C03;&#xFF0C;&#x65B0;&#x7684;&#x8BF7;&#x6C42;&#x6765;&#x5230;&#x65F6;&#x8C03;&#x7528;&#xFF0C;&#x4E00;&#x822C;&#x662F; Application &#x5BF9;&#x8C61;</span>

                HTTPConnection(stream, address, self.request_callback,
                               self.no_keep_alive, self.xheaders)
            <span class="hljs-keyword">except</span>:
                logging.error(<span class="hljs-string">&quot;Error in connection callback&quot;</span>, exc_info=<span class="hljs-keyword">True</span>)
</code></pre>
<h2 id="httpconnection">HTTPConnection</h2>
<ul>
<li>&#x5C01;&#x88C5;&#x4E86;&#x4E00;&#x4E2A; http &#x8FDE;&#x63A5;&#x5BF9;&#x8C61;</li>
<li>&#x5728;&#x521D;&#x59CB;&#x5316;&#x51FD;&#x6570;&#x4E2D;&#x5B8C;&#x6210; http &#x5934;&#x7684;&#x63A5;&#x6536;&#x548C;&#x89E3;&#x6790;</li>
<li>&#x5B8C;&#x6210; header &#x6570;&#x636E;&#x63A5;&#x6536;&#x540E;&#xFF0C;&#x8C03;&#x7528; <code>_on_headers</code> &#x51FD;&#x6570;
&#x521B;&#x5EFA; HTTPRequest &#x5BF9;&#x8C61;&#xFF0C;&#x5E76;&#x4E14;&#x4EE5;&#x8BE5; request &#x5BF9;&#x8C61;&#x4E3A;&#x53C2;&#x6570;&#x8C03;&#x7528; self.request_callback &#x65B9;&#x6CD5;&#xFF0C;&#x8BE5;&#x65B9;&#x6CD5;&#x7ED1;&#x5B9A;&#x5230; HTTPServer &#x7684;&#x56DE;&#x8C03;</li>
</ul>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HTTPConnection</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-string">&quot;&quot;&quot;Handles a connection to an HTTP client, executing HTTP requests.

    We parse HTTP headers and bodies, and execute the request callback
    until the HTTP conection is closed.
    &quot;&quot;&quot;</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, stream, address, request_callback, no_keep_alive=False,
                 xheaders=False)</span>:</span>
        self.stream = stream
        self.address = address
        self.request_callback = request_callback
        self.no_keep_alive = no_keep_alive
        self.xheaders = xheaders
        self._request = <span class="hljs-keyword">None</span>
        self._request_finished = <span class="hljs-keyword">False</span>
        <span class="hljs-comment"># Save stack context here, outside of any request.  This keeps</span>
        <span class="hljs-comment"># contexts from one request from leaking into the next.</span>
        self._header_callback = stack_context.wrap(self._on_headers)
        self.stream.read_until(<span class="hljs-string">&quot;\r\n\r\n&quot;</span>, self._header_callback)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span><span class="hljs-params">(self, chunk)</span>:</span>
        <span class="hljs-keyword">assert</span> self._request, <span class="hljs-string">&quot;Request closed&quot;</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.stream.closed():
            self.stream.write(chunk, self._on_write_complete)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">finish</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">assert</span> self._request, <span class="hljs-string">&quot;Request closed&quot;</span>
        self._request_finished = <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.stream.writing():
            self._finish_request()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_write_complete</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">if</span> self._request_finished:
            self._finish_request()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_finish_request</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">if</span> self.no_keep_alive:
            disconnect = <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">else</span>:
            connection_header = self._request.headers.get(<span class="hljs-string">&quot;Connection&quot;</span>)
            <span class="hljs-keyword">if</span> self._request.supports_http_1_1():
                disconnect = connection_header == <span class="hljs-string">&quot;close&quot;</span>
            <span class="hljs-keyword">elif</span> (<span class="hljs-string">&quot;Content-Length&quot;</span> <span class="hljs-keyword">in</span> self._request.headers
                    <span class="hljs-keyword">or</span> self._request.method <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;HEAD&quot;</span>, <span class="hljs-string">&quot;GET&quot;</span>)):
                disconnect = connection_header != <span class="hljs-string">&quot;Keep-Alive&quot;</span>
            <span class="hljs-keyword">else</span>:
                disconnect = <span class="hljs-keyword">True</span>
        self._request = <span class="hljs-keyword">None</span>
        self._request_finished = <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">if</span> disconnect:
            self.stream.close()
            <span class="hljs-keyword">return</span>
        self.stream.read_until(<span class="hljs-string">&quot;\r\n\r\n&quot;</span>, self._header_callback)

    <span class="hljs-comment"># &#x89E3;&#x6790; http &#x5934;&#x5E76;&#x6784;&#x9020; HTTPRequest</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_headers</span><span class="hljs-params">(self, data)</span>:</span>
        <span class="hljs-keyword">try</span>:
            eol = data.find(<span class="hljs-string">&quot;\r\n&quot;</span>)
            start_line = data[:eol]
            <span class="hljs-keyword">try</span>:
                method, uri, version = start_line.split(<span class="hljs-string">&quot; &quot;</span>)
            <span class="hljs-keyword">except</span> ValueError:
                <span class="hljs-keyword">raise</span> _BadRequestException(<span class="hljs-string">&quot;Malformed HTTP request line&quot;</span>)
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> version.startswith(<span class="hljs-string">&quot;HTTP/&quot;</span>):
                <span class="hljs-keyword">raise</span> _BadRequestException(<span class="hljs-string">&quot;Malformed HTTP version in HTTP Request-Line&quot;</span>)
            headers = httputil.HTTPHeaders.parse(data[eol:])
            self._request = HTTPRequest(
                connection=self, method=method, uri=uri, version=version,
                headers=headers, remote_ip=self.address[<span class="hljs-number">0</span>])

            content_length = headers.get(<span class="hljs-string">&quot;Content-Length&quot;</span>)
            <span class="hljs-keyword">if</span> content_length:
                content_length = int(content_length)
                <span class="hljs-keyword">if</span> content_length &gt; self.stream.max_buffer_size:
                    <span class="hljs-keyword">raise</span> _BadRequestException(<span class="hljs-string">&quot;Content-Length too long&quot;</span>)
                <span class="hljs-keyword">if</span> headers.get(<span class="hljs-string">&quot;Expect&quot;</span>) == <span class="hljs-string">&quot;100-continue&quot;</span>:
                    self.stream.write(<span class="hljs-string">&quot;HTTP/1.1 100 (Continue)\r\n\r\n&quot;</span>)
                self.stream.read_bytes(content_length, self._on_request_body)
                <span class="hljs-keyword">return</span>

            self.request_callback(self._request)
        <span class="hljs-keyword">except</span> _BadRequestException, e:
            logging.info(<span class="hljs-string">&quot;Malformed HTTP request from %s: %s&quot;</span>,
                         self.address[<span class="hljs-number">0</span>], e)
            self.stream.close()
            <span class="hljs-keyword">return</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_on_request_body</span><span class="hljs-params">(self, data)</span>:</span>
        self._request.body = data
        content_type = self._request.headers.get(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)
        <span class="hljs-keyword">if</span> self._request.method <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>):
            <span class="hljs-keyword">if</span> content_type.startswith(<span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>):
                arguments = cgi.parse_qs(self._request.body)
                <span class="hljs-keyword">for</span> name, values <span class="hljs-keyword">in</span> arguments.iteritems():
                    values = [v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values <span class="hljs-keyword">if</span> v]
                    <span class="hljs-keyword">if</span> values:
                        self._request.arguments.setdefault(name, []).extend(
                            values)
            <span class="hljs-keyword">elif</span> content_type.startswith(<span class="hljs-string">&quot;multipart/form-data&quot;</span>):
                fields = content_type.split(<span class="hljs-string">&quot;;&quot;</span>)
                <span class="hljs-keyword">for</span> field <span class="hljs-keyword">in</span> fields:
                    k, sep, v = field.strip().partition(<span class="hljs-string">&quot;=&quot;</span>)
                    <span class="hljs-keyword">if</span> k == <span class="hljs-string">&quot;boundary&quot;</span> <span class="hljs-keyword">and</span> v:
                        self._parse_mime_body(v, data)
                        <span class="hljs-keyword">break</span>
                <span class="hljs-keyword">else</span>:
                    logging.warning(<span class="hljs-string">&quot;Invalid multipart/form-data&quot;</span>)
        self.request_callback(self._request)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_parse_mime_body</span><span class="hljs-params">(self, boundary, data)</span>:</span>
        <span class="hljs-comment"># The standard allows for the boundary to be quoted in the header,</span>
        <span class="hljs-comment"># although it&apos;s rare (it happens at least for google app engine</span>
        <span class="hljs-comment"># xmpp).  I think we&apos;re also supposed to handle backslash-escapes</span>
        <span class="hljs-comment"># here but I&apos;ll save that until we see a client that uses them</span>
        <span class="hljs-comment"># in the wild.</span>
        <span class="hljs-keyword">if</span> boundary.startswith(<span class="hljs-string">&apos;&quot;&apos;</span>) <span class="hljs-keyword">and</span> boundary.endswith(<span class="hljs-string">&apos;&quot;&apos;</span>):
            boundary = boundary[<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>]
        <span class="hljs-keyword">if</span> data.endswith(<span class="hljs-string">&quot;\r\n&quot;</span>):
            footer_length = len(boundary) + <span class="hljs-number">6</span>
        <span class="hljs-keyword">else</span>:
            footer_length = len(boundary) + <span class="hljs-number">4</span>
        parts = data[:-footer_length].split(<span class="hljs-string">&quot;--&quot;</span> + boundary + <span class="hljs-string">&quot;\r\n&quot;</span>)
        <span class="hljs-keyword">for</span> part <span class="hljs-keyword">in</span> parts:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> part: <span class="hljs-keyword">continue</span>
            eoh = part.find(<span class="hljs-string">&quot;\r\n\r\n&quot;</span>)
            <span class="hljs-keyword">if</span> eoh == <span class="hljs-number">-1</span>:
                logging.warning(<span class="hljs-string">&quot;multipart/form-data missing headers&quot;</span>)
                <span class="hljs-keyword">continue</span>
            headers = httputil.HTTPHeaders.parse(part[:eoh])
            name_header = headers.get(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name_header.startswith(<span class="hljs-string">&quot;form-data;&quot;</span>) <span class="hljs-keyword">or</span> \
               <span class="hljs-keyword">not</span> part.endswith(<span class="hljs-string">&quot;\r\n&quot;</span>):
                logging.warning(<span class="hljs-string">&quot;Invalid multipart/form-data&quot;</span>)
                <span class="hljs-keyword">continue</span>
            value = part[eoh + <span class="hljs-number">4</span>:<span class="hljs-number">-2</span>]
            name_values = {}
            <span class="hljs-keyword">for</span> name_part <span class="hljs-keyword">in</span> name_header[<span class="hljs-number">10</span>:].split(<span class="hljs-string">&quot;;&quot;</span>):
                name, name_value = name_part.strip().split(<span class="hljs-string">&quot;=&quot;</span>, <span class="hljs-number">1</span>)
                name_values[name] = name_value.strip(<span class="hljs-string">&apos;&quot;&apos;</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name_values.get(<span class="hljs-string">&quot;name&quot;</span>):
                logging.warning(<span class="hljs-string">&quot;multipart/form-data value missing name&quot;</span>)
                <span class="hljs-keyword">continue</span>
            name = name_values[<span class="hljs-string">&quot;name&quot;</span>]
            <span class="hljs-keyword">if</span> name_values.get(<span class="hljs-string">&quot;filename&quot;</span>):
                ctype = headers.get(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/unknown&quot;</span>)
                self._request.files.setdefault(name, []).append(dict(
                    filename=name_values[<span class="hljs-string">&quot;filename&quot;</span>], body=value,
                    content_type=ctype))
            <span class="hljs-keyword">else</span>:
                self._request.arguments.setdefault(name, []).append(value)
</code></pre>
<h2 id="httprequest">HTTPRequest</h2>
<p>&#x5C01;&#x88C5; http &#x8BF7;&#x6C42;<br>&#x8FDE;&#x63A5;&#x4FE1;&#x606F; HTTPConnection &#x4FDD;&#x5B58;&#x5728; connection &#x4E2D;</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HTTPRequest</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-string">&quot;&quot;&quot;A single HTTP request.

    GET/POST arguments are available in the arguments property, which
    maps arguments names to lists of values (to support multiple values
    for individual names). Names and values are both unicode always.

    File uploads are available in the files property, which maps file
    names to list of files. Each file is a dictionary of the form
    {&quot;filename&quot;:..., &quot;content_type&quot;:..., &quot;body&quot;:...}. The content_type
    comes from the provided HTTP header and should not be trusted
    outright given that it can be easily forged.

    An HTTP request is attached to a single HTTP connection, which can
    be accessed through the &quot;connection&quot; attribute. Since connections
    are typically kept open in HTTP/1.1, multiple requests can be handled
    sequentially on a single connection.
    &quot;&quot;&quot;</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, method, uri, version=<span class="hljs-string">&quot;HTTP/1.0&quot;</span>, headers=None,
                 body=None, remote_ip=None, protocol=None, host=None,
                 files=None, connection=None)</span>:</span>
        self.method = method
        self.uri = uri
        self.version = version
        self.headers = headers <span class="hljs-keyword">or</span> httputil.HTTPHeaders()
        self.body = body <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;&quot;</span>
        <span class="hljs-keyword">if</span> connection <span class="hljs-keyword">and</span> connection.xheaders:
            <span class="hljs-comment"># Squid uses X-Forwarded-For, others use X-Real-Ip</span>
            self.remote_ip = self.headers.get(
                <span class="hljs-string">&quot;X-Real-Ip&quot;</span>, self.headers.get(<span class="hljs-string">&quot;X-Forwarded-For&quot;</span>, remote_ip))
            <span class="hljs-comment"># AWS uses X-Forwarded-Proto</span>
            self.protocol = self.headers.get(
                <span class="hljs-string">&quot;X-Scheme&quot;</span>, self.headers.get(<span class="hljs-string">&quot;X-Forwarded-Proto&quot;</span>, protocol))
            <span class="hljs-keyword">if</span> self.protocol <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">&quot;http&quot;</span>, <span class="hljs-string">&quot;https&quot;</span>):
                self.protocol = <span class="hljs-string">&quot;http&quot;</span>
        <span class="hljs-keyword">else</span>:
            self.remote_ip = remote_ip
            <span class="hljs-keyword">if</span> protocol:
                self.protocol = protocol
            <span class="hljs-keyword">elif</span> connection <span class="hljs-keyword">and</span> isinstance(connection.stream,
                                           iostream.SSLIOStream):
                self.protocol = <span class="hljs-string">&quot;https&quot;</span>
            <span class="hljs-keyword">else</span>:
                self.protocol = <span class="hljs-string">&quot;http&quot;</span>
        self.host = host <span class="hljs-keyword">or</span> self.headers.get(<span class="hljs-string">&quot;Host&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span>
        self.files = files <span class="hljs-keyword">or</span> {}
        self.connection = connection
        self._start_time = time.time()
        self._finish_time = <span class="hljs-keyword">None</span>

        scheme, netloc, path, query, fragment = urlparse.urlsplit(uri)
        self.path = path
        self.query = query
        arguments = cgi.parse_qs(query)
        self.arguments = {}
        <span class="hljs-keyword">for</span> name, values <span class="hljs-keyword">in</span> arguments.iteritems():
            values = [v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values <span class="hljs-keyword">if</span> v]
            <span class="hljs-keyword">if</span> values: self.arguments[name] = values

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">supports_http_1_1</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Returns True if this request supports HTTP/1.1 semantics&quot;&quot;&quot;</span>
        <span class="hljs-keyword">return</span> self.version == <span class="hljs-string">&quot;HTTP/1.1&quot;</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span><span class="hljs-params">(self, chunk)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Writes the given chunk to the response stream.&quot;&quot;&quot;</span>
        <span class="hljs-keyword">assert</span> isinstance(chunk, str)
        self.connection.write(chunk)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">finish</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Finishes this HTTP request on the open connection.&quot;&quot;&quot;</span>
        self.connection.finish()
        self._finish_time = time.time()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">full_url</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Reconstructs the full URL for this request.&quot;&quot;&quot;</span>
        <span class="hljs-keyword">return</span> self.protocol + <span class="hljs-string">&quot;://&quot;</span> + self.host + self.uri

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request_time</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Returns the amount of time it took for this request to execute.&quot;&quot;&quot;</span>
        <span class="hljs-keyword">if</span> self._finish_time <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> time.time() - self._start_time
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> self._finish_time - self._start_time

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_ssl_certificate</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Returns the client&apos;s SSL certificate, if any.

        To use client certificates, the HTTPServer must have been constructed
        with cert_reqs set in ssl_options, e.g.:
            server = HTTPServer(app,
                ssl_options=dict(
                    certfile=&quot;foo.crt&quot;,
                    keyfile=&quot;foo.key&quot;,
                    cert_reqs=ssl.CERT_REQUIRED,
                    ca_certs=&quot;cacert.crt&quot;))

        The return value is a dictionary, see SSLSocket.getpeercert() in
        the standard library for more details.
        http://docs.python.org/library/ssl.html#sslsocket-objects
        &quot;&quot;&quot;</span>
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">return</span> self.connection.stream.socket.getpeercert()
        <span class="hljs-keyword">except</span> ssl.SSLError:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>
        attrs = (<span class="hljs-string">&quot;protocol&quot;</span>, <span class="hljs-string">&quot;host&quot;</span>, <span class="hljs-string">&quot;method&quot;</span>, <span class="hljs-string">&quot;uri&quot;</span>, <span class="hljs-string">&quot;version&quot;</span>, <span class="hljs-string">&quot;remote_ip&quot;</span>,
                 <span class="hljs-string">&quot;body&quot;</span>)
        args = <span class="hljs-string">&quot;, &quot;</span>.join([<span class="hljs-string">&quot;%s=%r&quot;</span> % (n, getattr(self, n)) <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> attrs])
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;%s(%s, headers=%s)&quot;</span> % (
            self.__class__.__name__, args, dict(self.headers))
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="web.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: web.py">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"httpserver.py","level":"1.1.6.2","depth":3,"previous":{"title":"web.py","level":"1.1.6.1","depth":3,"path":"tornado/web.md","ref":"tornado/web.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"tornado/httpserver.md","mtime":"2018-12-17T03:17:38.533Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-12-18T06:29:04.983Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

