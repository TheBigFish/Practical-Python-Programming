
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>iostream.py Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="httpserver.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="../misc/">
            
                <a href="../misc/">
            
                    
                    misc
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1.1" data-path="../misc/fork.html">
            
                <a href="../misc/fork.html">
            
                    
                    fork
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="../SocketServer/">
            
                <a href="../SocketServer/">
            
                    
                    socketserver
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.2.1" data-path="../SocketServer/socketserver.html">
            
                <a href="../SocketServer/socketserver.html">
            
                    
                    socketserver
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="../asyncore/">
            
                <a href="../asyncore/">
            
                    
                    asyncore
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.3.1" data-path="../asyncore/timer.html">
            
                <a href="../asyncore/timer.html">
            
                    
                    example-timer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3.2" data-path="../asyncore/echo.html">
            
                <a href="../asyncore/echo.html">
            
                    
                    example-echo
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3.3" data-path="../asyncore/asyncore.html">
            
                <a href="../asyncore/asyncore.html">
            
                    
                    source
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="../itertools/">
            
                <a href="../itertools/">
            
                    
                    itertools
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="../fn.py/">
            
                <a href="../fn.py/">
            
                    
                    fn.py
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.5.1" data-path="../fn.py/op.html">
            
                <a href="../fn.py/op.html">
            
                    
                    op
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5.2" data-path="../fn.py/func.html">
            
                <a href="../fn.py/func.html">
            
                    
                    func
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5.3" data-path="../fn.py/stream.html">
            
                <a href="../fn.py/stream.html">
            
                    
                    stream
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="../tablib/">
            
                <a href="../tablib/">
            
                    
                    tablib
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="./">
            
                <a href="./">
            
                    
                    tornado
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.7.1" data-path="stack_context.1.html">
            
                <a href="stack_context.1.html">
            
                    
                    stack_context_1.py
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7.2" data-path="ioloop.html">
            
                <a href="ioloop.html">
            
                    
                    ioloop.py
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7.3" data-path="web.html">
            
                <a href="web.html">
            
                    
                    web.py
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7.4" data-path="httpserver.html">
            
                <a href="httpserver.html">
            
                    
                    httpserver.py
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.7.5" data-path="iostream.html">
            
                <a href="iostream.html">
            
                    
                    iostream.py
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >iostream.py</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="iostreampy">iostream.py</h1>
<blockquote>
<p>A utility class to write to and read from a non-blocking socket.</p>
</blockquote>
<p>IOStream &#x5BF9; socket &#x8FDB;&#x884C;&#x5305;&#x88C5;&#xFF0C;&#x91C7;&#x7528;&#x6CE8;&#x518C;&#x56DE;&#x8C03;&#x65B9;&#x5F0F;&#x5B9E;&#x73B0;&#x975E;&#x963B;&#x585E;&#x3002;<br>&#x901A;&#x8FC7;&#x63A5;&#x53E3;&#x6CE8;&#x518C;&#x5404;&#x4E2A;&#x4E8B;&#x4EF6;&#x56DE;&#x8C03;</p>
<ul>
<li>_read_callback</li>
<li>_write_callback</li>
<li>_close_callback</li>
<li>_connect_callback</li>
</ul>
<p>ioloop &#x4E2D; socket &#x4E8B;&#x4EF6;&#x53D1;&#x751F;&#x540E;&#xFF0C;&#x8C03;&#x7528; IOStream._handle_events &#x65B9;&#x6CD5;&#xFF0C;&#x5BF9;&#x4E8B;&#x4EF6;&#x8FDB;&#x884C;&#x5206;&#x53D1;&#x3002;<br>&#x5BF9;&#x5E94;&#x7684;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x5982;&#x679C;&#x6EE1;&#x8DB3;&#x6CE8;&#x518C;&#x7684;&#x56DE;&#x8C03;&#x6761;&#x4EF6;&#xFF0C;&#x5219;&#x8C03;&#x7528;&#x56DE;&#x8C03;&#x51FD;&#x6570;<br>&#x56DE;&#x8C03;&#x51FD;&#x6570;&#x5728; IOStream._handle_events &#x4E2D;&#x88AB;&#x8C03;&#x7528;</p>
<h2 id="contents">contents</h2>
<ul>
<li><a href="#iostreampy">iostream.py</a><ul>
<li><a href="#contents">contents</a></li>
<li><a href="#example">example</a></li>
<li><a href="#head">head</a></li>
<li><a href="#iostreaminit">IOStream.__init__</a></li>
<li><a href="#iostreamconnect">IOStream.connect</a></li>
<li><a href="#iostreamreaduntil">IOStream.read_until</a></li>
<li><a href="#iostreamreadbytes">IOStream.read_bytes</a></li>
<li><a href="#iostreamwrite">IOStream.write</a></li>
<li><a href="#iostreamclose">IOStream.close</a></li>
<li><a href="#iostreamhandleevents">IOStream._handle_events</a></li>
<li><a href="#iostreamruncallback">IOStream._run_callback</a></li>
<li><a href="#iostreamruncallback-1">IOStream._run_callback</a></li>
<li><a href="#iostreamreadfromsocket">IOStream._read_from_socket</a></li>
<li><a href="#iostreamreadtobuffer">IOStream._read_to_buffer</a></li>
<li><a href="#iostreamreadfrombuffer">IOStream._read_from_buffer</a></li>
<li><a href="#iostreamhandleconnect">IOStream._handle_connect</a></li>
<li><a href="#iostreamhandlewrite">IOStream._handle_write</a></li>
<li><a href="#iostreamconsume">IOStream._consume</a></li>
<li><a href="#iostreamaddiostate">IOStream._add_io_state</a></li>
<li><a href="#iostreamreadbuffersize">IOStream._read_buffer_size</a></li>
<li><a href="#copyright">copyright</a></li>
</ul>
</li>
</ul>
<h2 id="example">example</h2>
<p>&#x4E00;&#x4E2A;&#x7B80;&#x5355;&#x7684; IOStream &#x5BA2;&#x6237;&#x7AEF;&#x793A;&#x4F8B;<br><strong>&#x7531;&#x6B64;&#x53EF;&#x89C1;&#xFF0C; IOStream &#x662F;&#x4E00;&#x4E2A;&#x5F02;&#x6B65;&#x56DE;&#x8C03;&#x94FE;</strong></p>
<ol>
<li>&#x521B;&#x5EFA; socket</li>
<li>&#x521B;&#x5EFA; IOStream &#x5BF9;&#x8C61;</li>
<li>&#x8FDE;&#x63A5;&#x5230;&#x4E3B;&#x673A;&#xFF0C;&#x4F20;&#x5165;&#x8FDE;&#x63A5;&#x6210;&#x529F;&#x540E;&#x56DE;&#x8C03;&#x51FD;&#x6570; send_request</li>
<li>socket &#x8F93;&#x51FA;&#x6570;&#x636E;&#x8BF7;&#x6C42;&#x9875;&#x9762;&#xFF0C;&#x8BFB;&#x53D6; head,&#x4F20;&#x5165;&#x8BFB;&#x53D6; head &#x6210;&#x529F;&#x540E;&#x56DE;&#x8C03;&#x51FD;&#x6570; on_headers</li>
<li>&#x7EE7;&#x7EED;&#x8BFB;&#x53D6; body,&#x4F20;&#x5165;&#x8BFB;&#x53D6; body &#x6210;&#x529F;&#x540E;&#x56DE;&#x8C03;&#x51FD;&#x6570; on_body</li>
<li>&#x5173;&#x95ED; stream&#xFF0C;&#x5173;&#x95ED; ioloop</li>
</ol>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> tornado <span class="hljs-keyword">import</span> ioloop
<span class="hljs-keyword">from</span> tornado <span class="hljs-keyword">import</span> iostream
<span class="hljs-keyword">import</span> socket


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send_request</span><span class="hljs-params">()</span>:</span>
    stream.write(<span class="hljs-string">&quot;GET / HTTP/1.0\r\nHost: baidu.com\r\n\r\n&quot;</span>)
    stream.read_until(<span class="hljs-string">&quot;\r\n\r\n&quot;</span>, on_headers)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_headers</span><span class="hljs-params">(data)</span>:</span>
    headers = {}
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> data.split(<span class="hljs-string">&quot;\r\n&quot;</span>):
        parts = line.split(<span class="hljs-string">&quot;:&quot;</span>)
        <span class="hljs-keyword">if</span> len(parts) == <span class="hljs-number">2</span>:
            headers[parts[<span class="hljs-number">0</span>].strip()] = parts[<span class="hljs-number">1</span>].strip()
    stream.read_bytes(int(headers[<span class="hljs-string">&quot;Content-Length&quot;</span>]), on_body)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_body</span><span class="hljs-params">(data)</span>:</span>
    <span class="hljs-keyword">print</span> data
    stream.close()
    ioloop.IOLoop.instance().stop()


s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, <span class="hljs-number">0</span>)
stream = iostream.IOStream(s)
stream.connect((<span class="hljs-string">&quot;baidu.com&quot;</span>, <span class="hljs-number">80</span>), send_request)
ioloop.IOLoop.instance().start()


<span class="hljs-comment"># html&gt;</span>
<span class="hljs-comment"># &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;        url=http://www.baidu.com/&quot;&gt;</span>
<span class="hljs-comment"># &lt;/html&gt;</span>
</code></pre>
<h2 id="head">head</h2>
<pre><code class="lang-python">
<span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> with_statement

<span class="hljs-keyword">import</span> collections
<span class="hljs-keyword">import</span> errno
<span class="hljs-keyword">import</span> logging
<span class="hljs-keyword">import</span> socket
<span class="hljs-keyword">import</span> sys

<span class="hljs-keyword">from</span> tornado <span class="hljs-keyword">import</span> ioloop
<span class="hljs-keyword">from</span> tornado <span class="hljs-keyword">import</span> stack_context

<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">import</span> ssl <span class="hljs-comment"># Python 2.6+</span>
<span class="hljs-keyword">except</span> ImportError:
    ssl = <span class="hljs-keyword">None</span>
</code></pre>
<h2 id="iostreaminit">IOStream.__init__</h2>
<p>&#x5305;&#x88C5; socket &#x7C7B;<br>&#x5173;&#x952E;&#x8BED;&#x53E5; <code>self.io_loop.add_handler( self.socket.fileno(), self._handle_events, self._state)</code> &#x5C06;&#x81EA;&#x8EAB;&#x7684;_handle_events &#x52A0;&#x5165;&#x5230;&#x5168;&#x5C40; ioloop poll &#x4E8B;&#x4EF6;&#x56DE;&#x8C03;<br>&#x6B64;&#x65F6;&#x53EA;&#x6CE8;&#x518C;&#x4E86; ERROR &#x7C7B;&#x578B;&#x4E8B;&#x4EF6;</p>
<p>_read_buffer: &#x8BFB;&#x7F13;&#x51B2;</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IOStream</span><span class="hljs-params">(object)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, socket, io_loop=None, max_buffer_size=<span class="hljs-number">104857600</span>,
                 read_chunk_size=<span class="hljs-number">4096</span>)</span>:</span>
        self.socket = socket
        self.socket.setblocking(<span class="hljs-keyword">False</span>)
        self.io_loop = io_loop <span class="hljs-keyword">or</span> ioloop.IOLoop.instance()
        self.max_buffer_size = max_buffer_size
        self.read_chunk_size = read_chunk_size
        self._read_buffer = collections.deque()
        self._write_buffer = collections.deque()
        self._write_buffer_frozen = <span class="hljs-keyword">False</span>
        self._read_delimiter = <span class="hljs-keyword">None</span>
        self._read_bytes = <span class="hljs-keyword">None</span>
        self._read_callback = <span class="hljs-keyword">None</span>
        self._write_callback = <span class="hljs-keyword">None</span>
        self._close_callback = <span class="hljs-keyword">None</span>
        self._connect_callback = <span class="hljs-keyword">None</span>
        self._connecting = <span class="hljs-keyword">False</span>
        self._state = self.io_loop.ERROR
        <span class="hljs-keyword">with</span> stack_context.NullContext():
            self.io_loop.add_handler(
                self.socket.fileno(), self._handle_events, self._state)
</code></pre>
<h2 id="iostreamconnect">IOStream.connect</h2>
<p>&#x8FDE;&#x63A5; socket &#x5230;&#x8FDC;&#x7A0B;&#x5730;&#x5740;&#xFF0C;&#x975E;&#x963B;&#x585E;&#x6A21;&#x5F0F;</p>
<ol>
<li>&#x8FDE;&#x63A5; socket</li>
<li>&#x6CE8;&#x518C;&#x8FDE;&#x63A5;&#x5B8C;&#x6210;&#x56DE;&#x8C03;</li>
<li>poll &#x589E;&#x52A0; socket &#x5199;&#x4E8B;&#x4EF6;</li>
</ol>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connect</span><span class="hljs-params">(self, address, callback=None)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Connects the socket to a remote address without blocking.

        May only be called if the socket passed to the constructor was
        not previously connected.  The address parameter is in the
        same format as for socket.connect, i.e. a (host, port) tuple.
        If callback is specified, it will be called when the
        connection is completed.

        Note that it is safe to call IOStream.write while the
        connection is pending, in which case the data will be written
        as soon as the connection is ready.  Calling IOStream read
        methods before the socket is connected works on some platforms
        but is non-portable.
        &quot;&quot;&quot;</span>
        self._connecting = <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">try</span>:
            self.socket.connect(address)
        <span class="hljs-keyword">except</span> socket.error, e:
            <span class="hljs-comment"># In non-blocking mode connect() always raises an exception</span>
            <span class="hljs-keyword">if</span> e.args[<span class="hljs-number">0</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (errno.EINPROGRESS, errno.EWOULDBLOCK):
                <span class="hljs-keyword">raise</span>
        self._connect_callback = stack_context.wrap(callback)
        self._add_io_state(self.io_loop.WRITE)
</code></pre>
<h2 id="iostreamreaduntil">IOStream.read_until</h2>
<ol>
<li>&#x6CE8;&#x518C;&#x8BFB;&#x5B8C;&#x6210;&#x56DE;&#x8C03;</li>
<li>&#x5C1D;&#x8BD5;&#x4ECE;&#x7F13;&#x51B2;&#x4E2D;&#x8BFB;</li>
<li>&#x4ECE; socket &#x4E2D;&#x8BFB;&#x5230;&#x7F13;&#x51B2;&#x533A;</li>
<li>&#x91CD;&#x590D; 2,3,&#x6CA1;&#x6709;&#x6570;&#x636E;&#x5219;&#x9000;&#x51FA;</li>
<li>&#x5C06; socket &#x8BFB;&#x4E8B;&#x4EF6;&#x52A0;&#x5165; poll</li>
</ol>
<p>&#x5982;&#x679C;&#x7F13;&#x5B58;&#x4E2D;&#x6570;&#x636E;&#x6EE1;&#x8DB3;&#x6761;&#x4EF6;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x6267;&#x884C; callback &#x5E76;&#x8FD4;&#x56DE;&#xFF0C;<br>&#x5426;&#x5219;&#xFF0C;&#x4FDD;&#x5B58; callback &#x51FD;&#x6570;&#x4E0B;&#x6B21; read &#x4E8B;&#x4EF6;&#x53D1;&#x751F;&#x65F6;&#xFF0C;_handle_events &#x5904;&#x7406;&#x8BFB;&#x4E8B;&#x4EF6;&#x65F6;&#xFF0C;&#x518D;&#x8FDB;&#x884C;&#x68C0;&#x6D4B;&#x53CA;&#x8C03;&#x7528;</p>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_until</span><span class="hljs-params">(self, delimiter, callback)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Call callback when we read the given delimiter.&quot;&quot;&quot;</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> self._read_callback, <span class="hljs-string">&quot;Already reading&quot;</span>
        self._read_delimiter = delimiter
        self._read_callback = stack_context.wrap(callback)
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
            <span class="hljs-comment"># See if we&apos;ve already got the data from a previous read</span>
            <span class="hljs-keyword">if</span> self._read_from_buffer():
                <span class="hljs-keyword">return</span>
            self._check_closed()
            <span class="hljs-keyword">if</span> self._read_to_buffer() == <span class="hljs-number">0</span>:
                <span class="hljs-keyword">break</span>
        self._add_io_state(self.io_loop.READ)
</code></pre>
<h2 id="iostreamreadbytes">IOStream.read_bytes</h2>
<p>&#x53C2;&#x8003; read_until&#xFF0C;&#x8BFB;&#x9650;&#x5B9A;&#x5B57;&#x8282;</p>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_bytes</span><span class="hljs-params">(self, num_bytes, callback)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Call callback when we read the given number of bytes.&quot;&quot;&quot;</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> self._read_callback, <span class="hljs-string">&quot;Already reading&quot;</span>
        <span class="hljs-keyword">if</span> num_bytes == <span class="hljs-number">0</span>:
            callback(<span class="hljs-string">&quot;&quot;</span>)
            <span class="hljs-keyword">return</span>
        self._read_bytes = num_bytes
        self._read_callback = stack_context.wrap(callback)
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
            <span class="hljs-keyword">if</span> self._read_from_buffer():
                <span class="hljs-keyword">return</span>
            self._check_closed()
            <span class="hljs-keyword">if</span> self._read_to_buffer() == <span class="hljs-number">0</span>:
                <span class="hljs-keyword">break</span>
        self._add_io_state(self.io_loop.READ)
</code></pre>
<h2 id="iostreamwrite">IOStream.write</h2>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span><span class="hljs-params">(self, data, callback=None)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Write the given data to this stream.

        If callback is given, we call it when all of the buffered write
        data has been successfully written to the stream. If there was
        previously buffered write data and an old write callback, that
        callback is simply overwritten with this new callback.
        &quot;&quot;&quot;</span>
        self._check_closed()
        self._write_buffer.append(data)
        self._add_io_state(self.io_loop.WRITE)
        self._write_callback = stack_context.wrap(callback)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_close_callback</span><span class="hljs-params">(self, callback)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Call the given callback when the stream is closed.&quot;&quot;&quot;</span>
        self._close_callback = stack_context.wrap(callback)
</code></pre>
<h2 id="iostreamclose">IOStream.close</h2>
<ol>
<li>&#x4ECE; ioloop &#x79FB;&#x9664; socket &#x4E8B;&#x4EF6;</li>
<li>&#x5173;&#x95ED; socket</li>
<li>&#x8C03;&#x7528;&#x5173;&#x95ED;&#x56DE;&#x8C03;</li>
</ol>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Close this stream.&quot;&quot;&quot;</span>
        <span class="hljs-keyword">if</span> self.socket <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
            self.io_loop.remove_handler(self.socket.fileno())
            self.socket.close()
            self.socket = <span class="hljs-keyword">None</span>
            <span class="hljs-keyword">if</span> self._close_callback:
                self._run_callback(self._close_callback)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reading</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Returns true if we are currently reading from the stream.&quot;&quot;&quot;</span>
        <span class="hljs-keyword">return</span> self._read_callback <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">writing</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Returns true if we are currently writing to the stream.&quot;&quot;&quot;</span>
        <span class="hljs-keyword">return</span> bool(self._write_buffer)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">closed</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.socket <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>
</code></pre>
<h2 id="iostreamhandleevents">IOStream._handle_events</h2>
<p>&#x6838;&#x5FC3;&#x56DE;&#x8C03;<br>&#x4EFB;&#x4F55;&#x7C7B;&#x578B;&#x7684; socket &#x4E8B;&#x4EF6;&#x89E6;&#x53D1; ioloop &#x56DE;&#x8C03;_handle_events&#xFF0C;&#x7136;&#x540E;&#x5728;_handle_events &#x518D;&#x8FDB;&#x884C;&#x5206;&#x53D1;<br>&#x503C;&#x5F97;&#x6CE8;&#x610F;&#x7684;&#x662F;&#xFF0C;IOStream &#x4E0D;&#x5904;&#x7406;&#x8FDE;&#x63A5;&#x8BF7;&#x6C42;&#x7684; read &#x4E8B;&#x4EF6;<br><strong>&#x6CE8;&#x610F;</strong><br>&#x4F5C;&#x4E3A;&#x670D;&#x52A1;&#x7AEF;&#xFF0C;&#x9ED8;&#x8BA4;&#x4EE3;&#x7406;&#x7684;&#x662F;&#x5DF2;&#x7ECF;&#x5EFA;&#x7ACB;&#x8FDE;&#x63A5;&#x7684; socket</p>
<pre><code class="lang-python"><span class="hljs-comment"># HTTPServer.\_handle_events</span>
<span class="hljs-comment"># connection &#x4E3A;&#x5DF2;&#x7ECF;accept&#x7684;&#x8FDE;&#x63A5;</span>
stream = iostream.IOStream(connection, io_loop=self.io_loop)
</code></pre>
<p>&#x4F5C;&#x4E3A;&#x5BA2;&#x6237;&#x7AEF;&#xFF0C;&#x9700;&#x8981;&#x624B;&#x52A8;&#x8C03;&#x7528; IOStream.connect&#xFF0C;&#x8FDE;&#x63A5;&#x6210;&#x529F;&#x540E;&#xFF0C;&#x6210;&#x529F;&#x56DE;&#x8C03;&#x5728; write &#x4E8B;&#x4EF6;&#x4E2D;&#x5904;&#x7406;</p>
<p>&#x8FD9;&#x4E2A;&#x5B9E;&#x73B0;&#x6BD4;&#x8F83;&#x522B;&#x626D;</p>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_handle_events</span><span class="hljs-params">(self, fd, events)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.socket:
            logging.warning(<span class="hljs-string">&quot;Got events for closed stream %d&quot;</span>, fd)
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">try</span>:
            <span class="hljs-comment"># &#x5904;&#x7406;&#x8BFB;&#x4E8B;&#x4EF6;&#xFF0C;&#x8C03;&#x7528;&#x5DF2;&#x6CE8;&#x518C;&#x56DE;&#x8C03;</span>
            <span class="hljs-keyword">if</span> events &amp; self.io_loop.READ:
                self._handle_read()
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.socket:
                <span class="hljs-keyword">return</span>
            <span class="hljs-comment"># &#x5904;&#x7406;&#x5199;&#x4E8B;&#x4EF6;&#xFF0C;&#x5982;&#x679C;&#x662F;&#x521A;&#x5EFA;&#x7ACB;&#x8FDE;&#x63A5;&#xFF0C;&#x8C03;&#x7528;&#x8FDE;&#x63A5;&#x5EFA;&#x7ACB;&#x56DE;&#x8C03;</span>
            <span class="hljs-keyword">if</span> events &amp; self.io_loop.WRITE:
                <span class="hljs-keyword">if</span> self._connecting:
                    self._handle_connect()
                self._handle_write()
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.socket:
                <span class="hljs-keyword">return</span>
            <span class="hljs-comment"># &#x9519;&#x8BEF;&#x4E8B;&#x4EF6;&#xFF0C;&#x5173;&#x95ED; socket</span>
            <span class="hljs-keyword">if</span> events &amp; self.io_loop.ERROR:
                self.close()
                <span class="hljs-keyword">return</span>
            state = self.io_loop.ERROR
            <span class="hljs-keyword">if</span> self.reading():
                state |= self.io_loop.READ
            <span class="hljs-keyword">if</span> self.writing():
                state |= self.io_loop.WRITE
            <span class="hljs-keyword">if</span> state != self._state:
                self._state = state
                self.io_loop.update_handler(self.socket.fileno(), self._state)
        <span class="hljs-keyword">except</span>:
            logging.error(<span class="hljs-string">&quot;Uncaught exception, closing connection.&quot;</span>,
                          exc_info=<span class="hljs-keyword">True</span>)
            self.close()
            <span class="hljs-keyword">raise</span>
</code></pre>
<h2 id="iostreamruncallback">IOStream._run_callback</h2>
<p>&#x6267;&#x884C;&#x56DE;&#x8C03;</p>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_run_callback</span><span class="hljs-params">(self, callback, *args, **kwargs)</span>:</span>
        <span class="hljs-keyword">try</span>:
            <span class="hljs-comment"># Use a NullContext to ensure that all StackContexts are run</span>
            <span class="hljs-comment"># inside our blanket exception handler rather than outside.</span>
            <span class="hljs-keyword">with</span> stack_context.NullContext():
                callback(*args, **kwargs)
        <span class="hljs-keyword">except</span>:
            logging.error(<span class="hljs-string">&quot;Uncaught exception, closing connection.&quot;</span>,
                          exc_info=<span class="hljs-keyword">True</span>)
            <span class="hljs-comment"># Close the socket on an uncaught exception from a user callback</span>
            <span class="hljs-comment"># (It would eventually get closed when the socket object is</span>
            <span class="hljs-comment"># gc&apos;d, but we don&apos;t want to rely on gc happening before we</span>
            <span class="hljs-comment"># run out of file descriptors)</span>
            self.close()
            <span class="hljs-comment"># Re-raise the exception so that IOLoop.handle_callback_exception</span>
            <span class="hljs-comment"># can see it and log the error</span>
            <span class="hljs-keyword">raise</span>
</code></pre>
<h2 id="iostreamruncallback">IOStream._run_callback</h2>
<p>&#x8BFB;&#x56DE;&#x8C03;</p>
<ol>
<li>&#x4ECE; socket &#x8BFB;&#x53D6;&#x6570;&#x636E;&#x5230;&#x7F13;&#x5B58;</li>
<li>&#x65E0;&#x6570;&#x636E;,socket &#x5173;&#x95ED;</li>
<li>&#x68C0;&#x6D4B;&#x662F;&#x5426;&#x6EE1;&#x8DB3; read_until read_bytes</li>
<li>&#x6EE1;&#x8DB3;&#x5219;&#x6267;&#x884C;&#x5BF9;&#x5E94;&#x56DE;&#x8C03;</li>
</ol>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_handle_read</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
            <span class="hljs-keyword">try</span>:
                <span class="hljs-comment"># Read from the socket until we get EWOULDBLOCK or equivalent.</span>
                <span class="hljs-comment"># SSL sockets do some internal buffering, and if the data is</span>
                <span class="hljs-comment"># sitting in the SSL object&apos;s buffer select() and friends</span>
                <span class="hljs-comment"># can&apos;t see it; the only way to find out if it&apos;s there is to</span>
                <span class="hljs-comment"># try to read it.</span>
                result = self._read_to_buffer()
            <span class="hljs-keyword">except</span> Exception:
                self.close()
                <span class="hljs-keyword">return</span>
            <span class="hljs-keyword">if</span> result == <span class="hljs-number">0</span>:
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">if</span> self._read_from_buffer():
                    <span class="hljs-keyword">return</span>
</code></pre>
<h2 id="iostreamreadfromsocket">IOStream._read_from_socket</h2>
<p>&#x4ECE; socket &#x8BFB;&#x53D6;&#x6570;&#x636E;</p>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_read_from_socket</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Attempts to read from the socket.

        Returns the data read or None if there is nothing to read.
        May be overridden in subclasses.
        &quot;&quot;&quot;</span>
        <span class="hljs-keyword">try</span>:
            chunk = self.socket.recv(self.read_chunk_size)
        <span class="hljs-keyword">except</span> socket.error, e:
            <span class="hljs-keyword">if</span> e.args[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">raise</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk:
            self.close()
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">return</span> chunk
</code></pre>
<h2 id="iostreamreadtobuffer">IOStream._read_to_buffer</h2>
<p>&#x4ECE; socket &#x8BFB;&#x53D6;&#x6570;&#x636E;&#x5B58;&#x5165;&#x7F13;&#x5B58;</p>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_read_to_buffer</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Reads from the socket and appends the result to the read buffer.

        Returns the number of bytes read.  Returns 0 if there is nothing
        to read (i.e. the read returns EWOULDBLOCK or equivalent).  On
        error closes the socket and raises an exception.
        &quot;&quot;&quot;</span>
        <span class="hljs-keyword">try</span>:
            chunk = self._read_from_socket()
        <span class="hljs-keyword">except</span> socket.error, e:
            <span class="hljs-comment"># ssl.SSLError is a subclass of socket.error</span>
            logging.warning(<span class="hljs-string">&quot;Read error on %d: %s&quot;</span>,
                            self.socket.fileno(), e)
            self.close()
            <span class="hljs-keyword">raise</span>
        <span class="hljs-keyword">if</span> chunk <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        self._read_buffer.append(chunk)
        <span class="hljs-keyword">if</span> self._read_buffer_size() &gt;= self.max_buffer_size:
            logging.error(<span class="hljs-string">&quot;Reached maximum read buffer size&quot;</span>)
            self.close()
            <span class="hljs-keyword">raise</span> IOError(<span class="hljs-string">&quot;Reached maximum read buffer size&quot;</span>)
        <span class="hljs-keyword">return</span> len(chunk)
</code></pre>
<h2 id="iostreamreadfrombuffer">IOStream._read_from_buffer</h2>
<p>&#x4ECE;&#x7F13;&#x51B2;&#x4E2D;&#x8FC7;&#x6EE4;&#x6570;&#x636E;<br>&#x68C0;&#x6D4B;&#x662F;&#x5426;&#x6EE1;&#x8DB3;&#x7ED3;&#x675F;&#x6761;&#x4EF6;(read_until/read_bytes)&#xFF0C;&#x6EE1;&#x8DB3;&#x5219;&#x8C03;&#x7528;&#x4E4B;&#x524D;&#x6CE8;&#x518C;&#x7684;&#x56DE;&#x8C03;<br>&#x91C7;&#x7528;&#x7684;&#x662F;&#x67E5;&#x8BE2;&#x65B9;&#x5F0F;</p>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_read_from_buffer</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Attempts to complete the currently-pending read from the buffer.

        Returns True if the read was completed.
        &quot;&quot;&quot;</span>
        <span class="hljs-keyword">if</span> self._read_bytes:
            <span class="hljs-keyword">if</span> self._read_buffer_size() &gt;= self._read_bytes:
                num_bytes = self._read_bytes
                callback = self._read_callback
                self._read_callback = <span class="hljs-keyword">None</span>
                self._read_bytes = <span class="hljs-keyword">None</span>
                self._run_callback(callback, self._consume(num_bytes))
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">elif</span> self._read_delimiter:
            _merge_prefix(self._read_buffer, sys.maxint)
            loc = self._read_buffer[<span class="hljs-number">0</span>].find(self._read_delimiter)
            <span class="hljs-keyword">if</span> loc != <span class="hljs-number">-1</span>:
                callback = self._read_callback
                delimiter_len = len(self._read_delimiter)
                self._read_callback = <span class="hljs-keyword">None</span>
                self._read_delimiter = <span class="hljs-keyword">None</span>
                self._run_callback(callback,
                                   self._consume(loc + delimiter_len))
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
</code></pre>
<h2 id="iostreamhandleconnect">IOStream._handle_connect</h2>
<p>&#x8C03;&#x7528;&#x8FDE;&#x63A5;&#x5EFA;&#x7ACB;&#x56DE;&#x8C03;&#xFF0C;&#x5E76;&#x6E05;&#x9664;&#x8FDE;&#x63A5;&#x4E2D;&#x6807;&#x5FD7;</p>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_handle_connect</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">if</span> self._connect_callback <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
            callback = self._connect_callback
            self._connect_callback = <span class="hljs-keyword">None</span>
            self._run_callback(callback)
        self._connecting = <span class="hljs-keyword">False</span>
</code></pre>
<h2 id="iostreamhandlewrite">IOStream._handle_write</h2>
<p>&#x5199;&#x4E8B;&#x4EF6;</p>
<ol>
<li>&#x4ECE;&#x7F13;&#x51B2;&#x533A;&#x83B7;&#x53D6;&#x9650;&#x5B9A;&#x8303;&#x56F4;&#x5185;&#x6570;&#x636E;</li>
<li>&#x8C03;&#x7528; socket.send &#x8F93;&#x51FA;&#x6570;&#x636E;</li>
<li>&#x5982;&#x679C;&#x6570;&#x636E;&#x53D1;&#x9001;&#x6211;&#x4E14;&#x5DF2;&#x6CE8;&#x518C;&#x56DE;&#x8C03;&#xFF0C;&#x8C03;&#x7528;&#x53D1;&#x9001;&#x5B8C;&#x6210;&#x56DE;&#x8C03;</li>
</ol>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_handle_write</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">while</span> self._write_buffer:
            <span class="hljs-keyword">try</span>:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._write_buffer_frozen:
                    <span class="hljs-comment"># On windows, socket.send blows up if given a</span>
                    <span class="hljs-comment"># write buffer that&apos;s too large, instead of just</span>
                    <span class="hljs-comment"># returning the number of bytes it was able to</span>
                    <span class="hljs-comment"># process.  Therefore we must not call socket.send</span>
                    <span class="hljs-comment"># with more than 128KB at a time.</span>
                    _merge_prefix(self._write_buffer, <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>)
                num_bytes = self.socket.send(self._write_buffer[<span class="hljs-number">0</span>])
                self._write_buffer_frozen = <span class="hljs-keyword">False</span>
                _merge_prefix(self._write_buffer, num_bytes)
                self._write_buffer.popleft()
            <span class="hljs-keyword">except</span> socket.error, e:
                <span class="hljs-keyword">if</span> e.args[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):
                    <span class="hljs-comment"># With OpenSSL, after send returns EWOULDBLOCK,</span>
                    <span class="hljs-comment"># the very same string object must be used on the</span>
                    <span class="hljs-comment"># next call to send.  Therefore we suppress</span>
                    <span class="hljs-comment"># merging the write buffer after an EWOULDBLOCK.</span>
                    <span class="hljs-comment"># A cleaner solution would be to set</span>
                    <span class="hljs-comment"># SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER, but this is</span>
                    <span class="hljs-comment"># not yet accessible from python</span>
                    <span class="hljs-comment"># (http://bugs.python.org/issue8240)</span>
                    self._write_buffer_frozen = <span class="hljs-keyword">True</span>
                    <span class="hljs-keyword">break</span>
                <span class="hljs-keyword">else</span>:
                    logging.warning(<span class="hljs-string">&quot;Write error on %d: %s&quot;</span>,
                                    self.socket.fileno(), e)
                    self.close()
                    <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._write_buffer <span class="hljs-keyword">and</span> self._write_callback:
            callback = self._write_callback
            self._write_callback = <span class="hljs-keyword">None</span>
            self._run_callback(callback)
</code></pre>
<h2 id="iostreamconsume">IOStream._consume</h2>
<p>&#x4ECE;&#x8BFB;&#x7F13;&#x5B58;&#x6D88;&#x8D39; loc &#x957F;&#x5EA6;&#x7684;&#x6570;&#x636E;</p>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_consume</span><span class="hljs-params">(self, loc)</span>:</span>
        _merge_prefix(self._read_buffer, loc)
        <span class="hljs-keyword">return</span> self._read_buffer.popleft()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_check_closed</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.socket:
            <span class="hljs-keyword">raise</span> IOError(<span class="hljs-string">&quot;Stream is closed&quot;</span>)
</code></pre>
<h2 id="iostreamaddiostate">IOStream._add_io_state</h2>
<p>&#x589E;&#x52A0; socket &#x4E8B;&#x4EF6;&#x72B6;&#x6001;</p>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_add_io_state</span><span class="hljs-params">(self, state)</span>:</span>
        <span class="hljs-keyword">if</span> self.socket <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            <span class="hljs-comment"># connection has been closed, so there can be no future events</span>
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self._state &amp; state:
            self._state = self._state | state
            self.io_loop.update_handler(self.socket.fileno(), self._state)
</code></pre>
<h2 id="iostreamreadbuffersize">IOStream._read_buffer_size</h2>
<p>&#x83B7;&#x53D6;&#x8BFB;&#x7F13;&#x5B58;&#x4E2D;&#x5DF2;&#x6709;&#x6570;&#x636E;&#x957F;&#x5EA6;</p>
<pre><code class="lang-python">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_read_buffer_size</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> sum(len(chunk) <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> self._read_buffer)


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SSLIOStream</span><span class="hljs-params">(IOStream)</span>:</span>
    <span class="hljs-string">&quot;&quot;&quot;A utility class to write to and read from a non-blocking socket.

    If the socket passed to the constructor is already connected,
    it should be wrapped with
        ssl.wrap_socket(sock, do_handshake_on_connect=False, **kwargs)
    before constructing the SSLIOStream.  Unconnected sockets will be
    wrapped when IOStream.connect is finished.
    &quot;&quot;&quot;</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, *args, **kwargs)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Creates an SSLIOStream.

        If a dictionary is provided as keyword argument ssl_options,
        it will be used as additional keyword arguments to ssl.wrap_socket.
        &quot;&quot;&quot;</span>
        self._ssl_options = kwargs.pop(<span class="hljs-string">&apos;ssl_options&apos;</span>, {})
        super(SSLIOStream, self).__init__(*args, **kwargs)
        self._ssl_accepting = <span class="hljs-keyword">True</span>
        self._handshake_reading = <span class="hljs-keyword">False</span>
        self._handshake_writing = <span class="hljs-keyword">False</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reading</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self._handshake_reading <span class="hljs-keyword">or</span> super(SSLIOStream, self).reading()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">writing</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self._handshake_writing <span class="hljs-keyword">or</span> super(SSLIOStream, self).writing()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_do_ssl_handshake</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># Based on code from test_ssl.py in the python stdlib</span>
        <span class="hljs-keyword">try</span>:
            self._handshake_reading = <span class="hljs-keyword">False</span>
            self._handshake_writing = <span class="hljs-keyword">False</span>
            self.socket.do_handshake()
        <span class="hljs-keyword">except</span> ssl.SSLError, err:
            <span class="hljs-keyword">if</span> err.args[<span class="hljs-number">0</span>] == ssl.SSL_ERROR_WANT_READ:
                self._handshake_reading = <span class="hljs-keyword">True</span>
                <span class="hljs-keyword">return</span>
            <span class="hljs-keyword">elif</span> err.args[<span class="hljs-number">0</span>] == ssl.SSL_ERROR_WANT_WRITE:
                self._handshake_writing = <span class="hljs-keyword">True</span>
                <span class="hljs-keyword">return</span>
            <span class="hljs-keyword">elif</span> err.args[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> (ssl.SSL_ERROR_EOF,
                                 ssl.SSL_ERROR_ZERO_RETURN):
                <span class="hljs-keyword">return</span> self.close()
            <span class="hljs-keyword">elif</span> err.args[<span class="hljs-number">0</span>] == ssl.SSL_ERROR_SSL:
                logging.warning(<span class="hljs-string">&quot;SSL Error on %d: %s&quot;</span>, self.socket.fileno(), err)
                <span class="hljs-keyword">return</span> self.close()
            <span class="hljs-keyword">raise</span>
        <span class="hljs-keyword">except</span> socket.error, err:
            <span class="hljs-keyword">if</span> err.args[<span class="hljs-number">0</span>] == errno.ECONNABORTED:
                <span class="hljs-keyword">return</span> self.close()
        <span class="hljs-keyword">else</span>:
            self._ssl_accepting = <span class="hljs-keyword">False</span>
            super(SSLIOStream, self)._handle_connect()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_handle_read</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">if</span> self._ssl_accepting:
            self._do_ssl_handshake()
            <span class="hljs-keyword">return</span>
        super(SSLIOStream, self)._handle_read()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_handle_write</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">if</span> self._ssl_accepting:
            self._do_ssl_handshake()
            <span class="hljs-keyword">return</span>
        super(SSLIOStream, self)._handle_write()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_handle_connect</span><span class="hljs-params">(self)</span>:</span>
        self.socket = ssl.wrap_socket(self.socket,
                                      do_handshake_on_connect=<span class="hljs-keyword">False</span>,
                                      **self._ssl_options)
        <span class="hljs-comment"># Don&apos;t call the superclass&apos;s _handle_connect (which is responsible</span>
        <span class="hljs-comment"># for telling the application that the connection is complete)</span>
        <span class="hljs-comment"># until we&apos;ve completed the SSL handshake (so certificates are</span>
        <span class="hljs-comment"># available, etc).</span>


    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_read_from_socket</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">try</span>:
            <span class="hljs-comment"># SSLSocket objects have both a read() and recv() method,</span>
            <span class="hljs-comment"># while regular sockets only have recv().</span>
            <span class="hljs-comment"># The recv() method blocks (at least in python 2.6) if it is</span>
            <span class="hljs-comment"># called when there is nothing to read, so we have to use</span>
            <span class="hljs-comment"># read() instead.</span>
            chunk = self.socket.read(self.read_chunk_size)
        <span class="hljs-keyword">except</span> ssl.SSLError, e:
            <span class="hljs-comment"># SSLError is a subclass of socket.error, so this except</span>
            <span class="hljs-comment"># block must come first.</span>
            <span class="hljs-keyword">if</span> e.args[<span class="hljs-number">0</span>] == ssl.SSL_ERROR_WANT_READ:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">raise</span>
        <span class="hljs-keyword">except</span> socket.error, e:
            <span class="hljs-keyword">if</span> e.args[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">raise</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk:
            self.close()
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">return</span> chunk

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_merge_prefix</span><span class="hljs-params">(deque, size)</span>:</span>
    <span class="hljs-string">&quot;&quot;&quot;Replace the first entries in a deque of strings with a single
    string of up to size bytes.

    &gt;&gt;&gt; d = collections.deque([&apos;abc&apos;, &apos;de&apos;, &apos;fghi&apos;, &apos;j&apos;])
    &gt;&gt;&gt; _merge_prefix(d, 5); print d
    deque([&apos;abcde&apos;, &apos;fghi&apos;, &apos;j&apos;])

    Strings will be split as necessary to reach the desired size.
    &gt;&gt;&gt; _merge_prefix(d, 7); print d
    deque([&apos;abcdefg&apos;, &apos;hi&apos;, &apos;j&apos;])

    &gt;&gt;&gt; _merge_prefix(d, 3); print d
    deque([&apos;abc&apos;, &apos;defg&apos;, &apos;hi&apos;, &apos;j&apos;])

    &gt;&gt;&gt; _merge_prefix(d, 100); print d
    deque([&apos;abcdefghij&apos;])
    &quot;&quot;&quot;</span>
    prefix = []
    remaining = size
    <span class="hljs-keyword">while</span> deque <span class="hljs-keyword">and</span> remaining &gt; <span class="hljs-number">0</span>:
        chunk = deque.popleft()
        <span class="hljs-keyword">if</span> len(chunk) &gt; remaining:
            deque.appendleft(chunk[remaining:])
            chunk = chunk[:remaining]
        prefix.append(chunk)
        remaining -= len(chunk)
    deque.appendleft(<span class="hljs-string">&apos;&apos;</span>.join(prefix))

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doctests</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">import</span> doctest
    <span class="hljs-keyword">return</span> doctest.DocTestSuite()
</code></pre>
<h2 id="copyright">copyright</h2>
<p>author&#xFF1A;bigfish<br>copyright: <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">&#x8BB8;&#x53EF;&#x534F;&#x8BAE; &#x77E5;&#x8BC6;&#x5171;&#x4EAB;&#x7F72;&#x540D;-&#x975E;&#x5546;&#x4E1A;&#x6027;&#x4F7F;&#x7528; 4.0 &#x56FD;&#x9645;&#x8BB8;&#x53EF;&#x534F;&#x8BAE;</a></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="httpserver.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: httpserver.py">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"iostream.py","level":"1.1.7.5","depth":3,"previous":{"title":"httpserver.py","level":"1.1.7.4","depth":3,"path":"tornado/httpserver.md","ref":"tornado/httpserver.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["livereload"],"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"tornado/iostream.md","mtime":"2018-12-21T02:26:21.826Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-12-21T06:41:17.291Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

