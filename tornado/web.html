
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>web.py Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="httpserver.html" />
    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="../SocketServer/">
            
                <a href="../SocketServer/">
            
                    
                    socketserver
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="../asyncore/">
            
                <a href="../asyncore/">
            
                    
                    asyncore
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.2.1" data-path="../asyncore/timer.html">
            
                <a href="../asyncore/timer.html">
            
                    
                    example-timer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2.2" data-path="../asyncore/echo.html">
            
                <a href="../asyncore/echo.html">
            
                    
                    example-echo
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2.3" data-path="../asyncore/asyncore.html">
            
                <a href="../asyncore/asyncore.html">
            
                    
                    source
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="../itertools/">
            
                <a href="../itertools/">
            
                    
                    itertools
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="../fn.py/">
            
                <a href="../fn.py/">
            
                    
                    fn.py
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.4.1" data-path="../fn.py/op.html">
            
                <a href="../fn.py/op.html">
            
                    
                    op
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4.2" data-path="../fn.py/func.html">
            
                <a href="../fn.py/func.html">
            
                    
                    func
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4.3" data-path="../fn.py/stream.html">
            
                <a href="../fn.py/stream.html">
            
                    
                    stream
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="../tablib/">
            
                <a href="../tablib/">
            
                    
                    tablib
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="./">
            
                <a href="./">
            
                    
                    tornado
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.1.6.1" data-path="web.html">
            
                <a href="web.html">
            
                    
                    web.py
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6.2" data-path="httpserver.html">
            
                <a href="httpserver.html">
            
                    
                    httpserver.py
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >web.py</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h2 id="urlspec">URLSpec</h2>
<p>URLs &#x548C; handlers &#x7684;&#x6620;&#x5C04;&#x5173;&#x7CFB;</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">URLSpec</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-string">&quot;&quot;&quot;Specifies mappings between URLs and handlers.&quot;&quot;&quot;</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, pattern, handler_class, kwargs={}, name=None)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Creates a URLSpec.

        Parameters:

        pattern: Regular expression to be matched.  Any groups in the regex
            will be passed in to the handler&apos;s get/post/etc methods as
            arguments.

        handler_class: RequestHandler subclass to be invoked.

        kwargs (optional): A dictionary of additional arguments to be passed
            to the handler&apos;s constructor.

        name (optional): A name for this handler.  Used by
            Application.reverse_url.
        &quot;&quot;&quot;</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pattern.endswith(<span class="hljs-string">&apos;$&apos;</span>):
            pattern += <span class="hljs-string">&apos;$&apos;</span>
        self.regex = re.compile(pattern)
        self.handler_class = handler_class
        self.kwargs = kwargs
        self.name = name
        self._path, self._group_count = self._find_groups()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_find_groups</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Returns a tuple (reverse string, group count) for a url.

        For example: Given the url pattern /([0-9]{4})/([a-z-]+)/, this method
        would return (&apos;/%s/%s/&apos;, 2).
        &quot;&quot;&quot;</span>

        <span class="hljs-comment"># &#x8FD4;&#x56DE;&#x6B63;&#x5219;&#x8868;&#x8FBE;&#x5F0F;&#x4E2D; &#x7EC4;&#x7684;&#x6570;&#x91CF;&#xFF0C;&#x4EE5;&#x53CA;&#x4EE5; /%s/&#x5BF9;&#x5E94;&#x7684;&#x5360;&#x4F4D;&#x7B26;</span>
        pattern = self.regex.pattern
        <span class="hljs-keyword">if</span> pattern.startswith(<span class="hljs-string">&apos;^&apos;</span>):
            pattern = pattern[<span class="hljs-number">1</span>:]
        <span class="hljs-keyword">if</span> pattern.endswith(<span class="hljs-string">&apos;$&apos;</span>):
            pattern = pattern[:<span class="hljs-number">-1</span>]

        <span class="hljs-keyword">if</span> self.regex.groups != pattern.count(<span class="hljs-string">&apos;(&apos;</span>):
            <span class="hljs-comment"># The pattern is too complicated for our simplistic matching,</span>
            <span class="hljs-comment"># so we can&apos;t support reversing it.</span>
            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">None</span>, <span class="hljs-keyword">None</span>)

        pieces = []
        <span class="hljs-comment"># &#x4EE5; &apos;(&apos; &#x5206;&#x5272;&#x5B57;&#x7B26;&#x4E32;&#xFF0C;&#x7136;&#x540E;&#x9010;&#x4E2A;&#x5339;&#x914D;&#x9879;&#x67E5;&#x627E; &apos;)&apos;&#xFF0C;&#x4EE5;&#x6B64;&#x4F5C;&#x4E3A;&#x5206;&#x7EC4;&#x4F9D;&#x636E;</span>
        <span class="hljs-keyword">for</span> fragment <span class="hljs-keyword">in</span> pattern.split(<span class="hljs-string">&apos;(&apos;</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-string">&apos;)&apos;</span> <span class="hljs-keyword">in</span> fragment:
                paren_loc = fragment.index(<span class="hljs-string">&apos;)&apos;</span>)
                <span class="hljs-keyword">if</span> paren_loc &gt;= <span class="hljs-number">0</span>:
                    pieces.append(<span class="hljs-string">&apos;%s&apos;</span> + fragment[paren_loc + <span class="hljs-number">1</span>:])
            <span class="hljs-keyword">else</span>:
                pieces.append(fragment)

        <span class="hljs-keyword">return</span> (<span class="hljs-string">&apos;&apos;</span>.join(pieces), self.regex.groups)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span><span class="hljs-params">(self, *args)</span>:</span>
        <span class="hljs-keyword">assert</span> self._path <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>, \
            <span class="hljs-string">&quot;Cannot reverse url regex &quot;</span> + self.regex.pattern
        <span class="hljs-keyword">assert</span> len(args) == self._group_count, <span class="hljs-string">&quot;required number of arguments &quot;</span>\
            <span class="hljs-string">&quot;not found&quot;</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> len(args):
            <span class="hljs-keyword">return</span> self._path
        <span class="hljs-comment"># &#x4F7F;&#x7528;&#x5217;&#x8868;&#x63A8;&#x5BFC;</span>
        <span class="hljs-keyword">return</span> self._path % tuple([str(a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> args])
</code></pre>
<h2 id="application">Application</h2>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-string">&quot;&quot;&quot;A collection of request handlers that make up a web application.

    Instances of this class are callable and can be passed directly to
    HTTPServer to serve the application::

        application = web.Application([
            (r&quot;/&quot;, MainPageHandler),
        ])
        http_server = httpserver.HTTPServer(application)
        http_server.listen(8080)
        ioloop.IOLoop.instance().start()

    The constructor for this class takes in a list of URLSpec objects
    or (regexp, request_class) tuples. When we receive requests, we
    iterate over the list in order and instantiate an instance of the
    first request class whose regexp matches the request path.

    Each tuple can contain an optional third element, which should be a
    dictionary if it is present. That dictionary is passed as keyword
    arguments to the contructor of the handler. This pattern is used
    for the StaticFileHandler below::

        application = web.Application([
            (r&quot;/static/(.*)&quot;, web.StaticFileHandler, {&quot;path&quot;: &quot;/var/www&quot;}),
        ])

    We support virtual hosts with the add_handlers method, which takes in
    a host regular expression as the first argument::

        application.add_handlers(r&quot;www\.myhost\.com&quot;, [
            (r&quot;/article/([0-9]+)&quot;, ArticleHandler),
        ])

    You can serve static files by sending the static_path setting as a
    keyword argument. We will serve those files from the /static/ URI
    (this is configurable with the static_url_prefix setting),
    and we will serve /favicon.ico and /robots.txt from the same directory.

    .. attribute:: settings

       Additonal keyword arguments passed to the constructor are saved in the
       `settings` dictionary, and are often referred to in documentation as
       &quot;application settings&quot;.
    &quot;&quot;&quot;</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, handlers=None, default_host=<span class="hljs-string">&quot;&quot;</span>, transforms=None,
                 wsgi=False, **settings)</span>:</span>
        <span class="hljs-comment"># &#x6587;&#x4EF6;&#x8FD4;&#x56DE;&#x6570;&#x636E;&#x7F16;&#x7801;&#x63D2;&#x4EF6;</span>
        <span class="hljs-comment"># Content-Encoding:gzip &#x538B;&#x7F29;&#x4F20;&#x8F93;</span>
        <span class="hljs-comment"># Transfer-Encoding:chunck &#x5757;&#x4F20;&#x8F93;</span>
        <span class="hljs-keyword">if</span> transforms <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            self.transforms = []
            <span class="hljs-keyword">if</span> settings.get(<span class="hljs-string">&quot;gzip&quot;</span>):
                self.transforms.append(GZipContentEncoding)
            self.transforms.append(ChunkedTransferEncoding)
        <span class="hljs-keyword">else</span>:
            self.transforms = transforms

        self.handlers = []
        self.named_handlers = {}
        self.default_host = default_host
        self.settings = settings
        <span class="hljs-comment"># &#x6A21;&#x677F;&#x4E2D;&#x4F7F;&#x7528;</span>
        self.ui_modules = {<span class="hljs-string">&apos;linkify&apos;</span>: _linkify,
                           <span class="hljs-string">&apos;xsrf_form_html&apos;</span>: _xsrf_form_html,
                           <span class="hljs-string">&apos;Template&apos;</span>: TemplateModule,
                           }
        self.ui_methods = {}
        self._wsgi = wsgi
        <span class="hljs-comment"># &#x52A0;&#x8F7D;&#x81EA;&#x5B9A;&#x4E49; ui_modules ui_methods</span>
        self._load_ui_modules(settings.get(<span class="hljs-string">&quot;ui_modules&quot;</span>, {}))
        self._load_ui_methods(settings.get(<span class="hljs-string">&quot;ui_methods&quot;</span>, {}))
        <span class="hljs-keyword">if</span> self.settings.get(<span class="hljs-string">&quot;static_path&quot;</span>):
            path = self.settings[<span class="hljs-string">&quot;static_path&quot;</span>]
            handlers = list(handlers <span class="hljs-keyword">or</span> [])
            static_url_prefix = settings.get(<span class="hljs-string">&quot;static_url_prefix&quot;</span>,
                                             <span class="hljs-string">&quot;/static/&quot;</span>)
            <span class="hljs-comment"># &#x4F7F;&#x7528; StaticFileHandler &#x5904;&#x7406;&#x9759;&#x6001;&#x6587;&#x4EF6;</span>
            handlers = [
                (re.escape(static_url_prefix) + <span class="hljs-string">r&quot;(.*)&quot;</span>, StaticFileHandler,
                 dict(path=path)),
                (<span class="hljs-string">r&quot;/(favicon\.ico)&quot;</span>, StaticFileHandler, dict(path=path)),
                (<span class="hljs-string">r&quot;/(robots\.txt)&quot;</span>, StaticFileHandler, dict(path=path)),
            ] + handlers
        <span class="hljs-comment"># &#x6CE8;&#x518C;&#x9759;&#x6001;&#x6587;&#x4EF6;&#x8DEF;&#x7531;</span>
        <span class="hljs-keyword">if</span> handlers: self.add_handlers(<span class="hljs-string">&quot;.*$&quot;</span>, handlers)

        <span class="hljs-comment"># Automatically reload modified modules</span>
        <span class="hljs-comment"># debug&#x6A21;&#x5F0F;&#x5219;&#x6253;&#x5F00;&#x6A21;&#x5757;&#x81EA;&#x52A8;&#x52A0;&#x8F7D;</span>
        <span class="hljs-keyword">if</span> self.settings.get(<span class="hljs-string">&quot;debug&quot;</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> wsgi:
            <span class="hljs-keyword">import</span> autoreload
            autoreload.start()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">listen</span><span class="hljs-params">(self, port, address=<span class="hljs-string">&quot;&quot;</span>, **kwargs)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Starts an HTTP server for this application on the given port.

        This is a convenience alias for creating an HTTPServer object
        and calling its listen method.  Keyword arguments not
        supported by HTTPServer.listen are passed to the HTTPServer
        constructor.  For advanced uses (e.g. preforking), do not use
        this method; create an HTTPServer and call its bind/start
        methods directly.

        Note that after calling this method you still need to call
        IOLoop.instance().start() to start the server.
        &quot;&quot;&quot;</span>
        <span class="hljs-comment"># import is here rather than top level because HTTPServer</span>
        <span class="hljs-comment"># is not importable on appengine</span>

        <span class="hljs-comment"># &#x6784;&#x9020;&#x4E00;&#x4E2A; HTTPServer &#x5E76;&#x8FDB;&#x884C;&#x4FA6;&#x542C;</span>
        <span class="hljs-comment"># &#x5C06;&#x81EA;&#x8EAB;&#x4F5C;&#x4E3A;&#x8BF7;&#x6C42;&#x56DE;&#x8C03;&#x4F20;&#x8FDB;&#x53BB;</span>
        <span class="hljs-comment"># &#x53EA;&#x662F;&#x4E00;&#x4E2A;&#x7B80;&#x4FBF;&#x65B9;&#x6CD5;</span>
        <span class="hljs-keyword">from</span> tornado.httpserver <span class="hljs-keyword">import</span> HTTPServer
        server = HTTPServer(self, **kwargs)
        server.listen(port, address)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_handlers</span><span class="hljs-params">(self, host_pattern, host_handlers)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Appends the given handlers to our handler list.

        Note that host patterns are processed sequentially in the
        order they were added, and only the first matching pattern is
        used.  This means that all handlers for a given host must be
        added in a single add_handlers call.
        &quot;&quot;&quot;</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> host_pattern.endswith(<span class="hljs-string">&quot;$&quot;</span>):
            host_pattern += <span class="hljs-string">&quot;$&quot;</span>
        handlers = []
        <span class="hljs-comment"># The handlers with the wildcard host_pattern are a special</span>
        <span class="hljs-comment"># case - they&apos;re added in the constructor but should have lower</span>
        <span class="hljs-comment"># precedence than the more-precise handlers added later.</span>
        <span class="hljs-comment"># If a wildcard handler group exists, it should always be last</span>
        <span class="hljs-comment"># in the list, so insert new groups just before it.</span>

        <span class="hljs-comment"># .*$ &#x8DEF;&#x7531;&#x5728;&#x8DEF;&#x7531;&#x8868;&#x7684;&#x6700;&#x540E;&#x9762;&#xFF0C;&#x4F18;&#x5148;&#x5339;&#x914D;&#x4E3B;&#x673A;&#x8DEF;&#x7531;</span>
        <span class="hljs-comment"># &#x6CE8;&#x610F;&#x6B64;&#x5904;&#x63D2;&#x5165;&#x7684;&#x662F;&#x7A7A;&#x8DEF;&#x7531;&#xFF0C;&#x4E0B;&#x9762;&#x7684;&#x5FAA;&#x73AF;&#x4E2D;&#x66F4;&#x65B0; handles&#xFF0C;&#x901A;&#x8FC7;&#x5F15;&#x7528;&#x800C;&#x540C;&#x65F6;&#x66F4;&#x65B0;</span>
        <span class="hljs-keyword">if</span> self.handlers <span class="hljs-keyword">and</span> self.handlers[<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>].pattern == <span class="hljs-string">&apos;.*$&apos;</span>:
            self.handlers.insert(<span class="hljs-number">-1</span>, (re.compile(host_pattern), handlers))
        <span class="hljs-keyword">else</span>:
            self.handlers.append((re.compile(host_pattern), handlers))

        <span class="hljs-keyword">for</span> spec <span class="hljs-keyword">in</span> host_handlers:
            <span class="hljs-keyword">if</span> type(spec) <span class="hljs-keyword">is</span> type(()):
                <span class="hljs-keyword">assert</span> len(spec) <span class="hljs-keyword">in</span> (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
                pattern = spec[<span class="hljs-number">0</span>]
                handler = spec[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">if</span> len(spec) == <span class="hljs-number">3</span>:
                    kwargs = spec[<span class="hljs-number">2</span>]
                <span class="hljs-keyword">else</span>:
                    kwargs = {}
                spec = URLSpec(pattern, handler, kwargs)
            handlers.append(spec)
            <span class="hljs-keyword">if</span> spec.name:
                <span class="hljs-keyword">if</span> spec.name <span class="hljs-keyword">in</span> self.named_handlers:
                    logging.warning(
                        <span class="hljs-string">&quot;Multiple handlers named %s; replacing previous value&quot;</span>,
                        spec.name)
                self.named_handlers[spec.name] = spec

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_transform</span><span class="hljs-params">(self, transform_class)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Adds the given OutputTransform to our transform list.&quot;&quot;&quot;</span>
        self.transforms.append(transform_class)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_host_handlers</span><span class="hljs-params">(self, request)</span>:</span>
        host = request.host.lower().split(<span class="hljs-string">&apos;:&apos;</span>)[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> pattern, handlers <span class="hljs-keyword">in</span> self.handlers:
            <span class="hljs-keyword">if</span> pattern.match(host):
                <span class="hljs-keyword">return</span> handlers
        <span class="hljs-comment"># Look for default host if not behind load balancer (for debugging)</span>
        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;X-Real-Ip&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> request.headers:
            <span class="hljs-keyword">for</span> pattern, handlers <span class="hljs-keyword">in</span> self.handlers:
                <span class="hljs-keyword">if</span> pattern.match(self.default_host):
                    <span class="hljs-keyword">return</span> handlers
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_load_ui_methods</span><span class="hljs-params">(self, methods)</span>:</span>
        <span class="hljs-keyword">if</span> type(methods) <span class="hljs-keyword">is</span> types.ModuleType:
            self._load_ui_methods(dict((n, getattr(methods, n))
                                       <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> dir(methods)))
        <span class="hljs-keyword">elif</span> isinstance(methods, list):
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> methods: self._load_ui_methods(m)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">for</span> name, fn <span class="hljs-keyword">in</span> methods.iteritems():
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name.startswith(<span class="hljs-string">&quot;_&quot;</span>) <span class="hljs-keyword">and</span> hasattr(fn, <span class="hljs-string">&quot;__call__&quot;</span>) \
                   <span class="hljs-keyword">and</span> name[<span class="hljs-number">0</span>].lower() == name[<span class="hljs-number">0</span>]:
                    self.ui_methods[name] = fn

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_load_ui_modules</span><span class="hljs-params">(self, modules)</span>:</span>
        <span class="hljs-keyword">if</span> type(modules) <span class="hljs-keyword">is</span> types.ModuleType:
            self._load_ui_modules(dict((n, getattr(modules, n))
                                       <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> dir(modules)))
        <span class="hljs-keyword">elif</span> isinstance(modules, list):
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> modules: self._load_ui_modules(m)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">assert</span> isinstance(modules, dict)
            <span class="hljs-keyword">for</span> name, cls <span class="hljs-keyword">in</span> modules.iteritems():
                <span class="hljs-keyword">try</span>:
                    <span class="hljs-keyword">if</span> issubclass(cls, UIModule):
                        self.ui_modules[name] = cls
                <span class="hljs-keyword">except</span> TypeError:
                    <span class="hljs-keyword">pass</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span><span class="hljs-params">(self, request)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Called by HTTPServer to execute the request.&quot;&quot;&quot;</span>
        transforms = [t(request) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> self.transforms]
        handler = <span class="hljs-keyword">None</span>
        args = []
        kwargs = {}
        handlers = self._get_host_handlers(request)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> handlers:
            handler = RedirectHandler(
                self, request, url=<span class="hljs-string">&quot;http://&quot;</span> + self.default_host + <span class="hljs-string">&quot;/&quot;</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">for</span> spec <span class="hljs-keyword">in</span> handlers:
                match = spec.regex.match(request.path)
                <span class="hljs-keyword">if</span> match:
                    <span class="hljs-comment"># None-safe wrapper around url_unescape to handle</span>
                    <span class="hljs-comment"># unmatched optional groups correctly</span>
                    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unquote</span><span class="hljs-params">(s)</span>:</span>
                        <span class="hljs-keyword">if</span> s <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>: <span class="hljs-keyword">return</span> s
                        <span class="hljs-keyword">return</span> escape.url_unescape(s, encoding=<span class="hljs-keyword">None</span>)
                    handler = spec.handler_class(self, request, **spec.kwargs)
                    <span class="hljs-comment"># Pass matched groups to the handler.  Since</span>
                    <span class="hljs-comment"># match.groups() includes both named and unnamed groups,</span>
                    <span class="hljs-comment"># we want to use either groups or groupdict but not both.</span>
                    <span class="hljs-comment"># Note that args are passed as bytes so the handler can</span>
                    <span class="hljs-comment"># decide what encoding to use.</span>
                    kwargs = dict((k, unquote(v))
                                  <span class="hljs-keyword">for</span> (k, v) <span class="hljs-keyword">in</span> match.groupdict().iteritems())
                    <span class="hljs-keyword">if</span> kwargs:
                        args = []
                    <span class="hljs-keyword">else</span>:
                        args = [unquote(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> match.groups()]
                    <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> handler:
                handler = ErrorHandler(self, request, status_code=<span class="hljs-number">404</span>)

        <span class="hljs-comment"># In debug mode, re-compile templates and reload static files on every</span>
        <span class="hljs-comment"># request so you don&apos;t need to restart to see changes</span>
        <span class="hljs-keyword">if</span> self.settings.get(<span class="hljs-string">&quot;debug&quot;</span>):
            <span class="hljs-keyword">if</span> getattr(RequestHandler, <span class="hljs-string">&quot;_templates&quot;</span>, <span class="hljs-keyword">None</span>):
                <span class="hljs-keyword">for</span> loader <span class="hljs-keyword">in</span> RequestHandler._templates.values():
                    loader.reset()
            RequestHandler._static_hashes = {}

        handler._execute(transforms, *args, **kwargs)
        <span class="hljs-keyword">return</span> handler

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_url</span><span class="hljs-params">(self, name, *args)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Returns a URL path for handler named `name`

        The handler must be added to the application as a named URLSpec
        &quot;&quot;&quot;</span>
        <span class="hljs-keyword">if</span> name <span class="hljs-keyword">in</span> self.named_handlers:
            <span class="hljs-keyword">return</span> self.named_handlers[name].reverse(*args)
        <span class="hljs-keyword">raise</span> KeyError(<span class="hljs-string">&quot;%s not found in named urls&quot;</span> % name)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log_request</span><span class="hljs-params">(self, handler)</span>:</span>
        <span class="hljs-string">&quot;&quot;&quot;Writes a completed HTTP request to the logs.

        By default writes to the python root logger.  To change
        this behavior either subclass Application and override this method,
        or pass a function in the application settings dictionary as
        &apos;log_function&apos;.
        &quot;&quot;&quot;</span>
        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;log_function&quot;</span> <span class="hljs-keyword">in</span> self.settings:
            self.settings[<span class="hljs-string">&quot;log_function&quot;</span>](handler)
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">if</span> handler.get_status() &lt; <span class="hljs-number">400</span>:
            log_method = logging.info
        <span class="hljs-keyword">elif</span> handler.get_status() &lt; <span class="hljs-number">500</span>:
            log_method = logging.warning
        <span class="hljs-keyword">else</span>:
            log_method = logging.error
        request_time = <span class="hljs-number">1000.0</span> * handler.request.request_time()
        log_method(<span class="hljs-string">&quot;%d %s %.2fms&quot;</span>, handler.get_status(),
                   handler._request_summary(), request_time)
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: tornado">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="httpserver.html" class="navigation navigation-next " aria-label="Next page: httpserver.py">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"web.py","level":"1.1.6.1","depth":3,"next":{"title":"httpserver.py","level":"1.1.6.2","depth":3,"path":"tornado/httpserver.md","ref":"tornado/httpserver.md","articles":[]},"previous":{"title":"tornado","level":"1.1.6","depth":2,"path":"tornado/README.md","ref":"tornado/README.md","articles":[{"title":"web.py","level":"1.1.6.1","depth":3,"path":"tornado/web.md","ref":"tornado/web.md","articles":[]},{"title":"httpserver.py","level":"1.1.6.2","depth":3,"path":"tornado/httpserver.md","ref":"tornado/httpserver.md","articles":[]}]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["livereload"],"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"tornado/web.md","mtime":"2018-12-14T06:28:21.920Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-12-18T07:20:03.549Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

